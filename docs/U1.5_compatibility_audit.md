# Phase U1.5: Scheduler Compatibility Audit Report

**Date**: 2025-12-12  
**Phase**: U1.5 - Compatibility Audit (Read-Only)  
**Critical Question**: **Is InventoryDevice 100% scheduler-safe?**

---

## Executive Summary

This audit comprehensively analyzes every scheduler dependency on the legacy `Device` model to verify if `InventoryDevice` can safely replace it **without code changes to the scheduler**.

**Answer**: üü° **InventoryDevice is 95% scheduler-safe with 3 CRITICAL RISKS**

**Risks Identified**:
1. üî¥ **deviceType property requires eager loading** (N+1 query risk)
2. üî¥ **status field semantics mismatch** (requires translation layer)
3. üü° **deviceType setter creates records** (side-effect in setter)

**Recommendation**: Proceed to Phase U2 with **specific query modifications** and **status mapping middleware**.

---

## Step 1: Full Scheduler Dependency Audit

### 1.1 Backend SQLAlchemy Queries

| Component | File | Line | Field Accessed | Query Type | Required Semantics |
|-----------|------|------|----------------|------------|-------------------|
| **admin.py** | routers/admin.py | 105 | `models.Device.deviceType` | Filter (equality) | String column for WHERE clause |
| **admin.py** | routers/admin.py | 106 | `models.Device.deviceName` | Filter (equality) | String column for WHERE clause |
| **admin.py** | routers/admin.py | 107 | `models.Device.polatis_name` | Filter (equality) | String column for WHERE clause |
| **admin.py** | routers/admin.py | 114 | `models.Device.ip_address` | Filter (equality) | String column for WHERE clause |
| **admin.py** | routers/admin.py | 116-117 | `models.Device.deviceType`, `deviceName` | Filter (inequality) | String columns for WHERE clause |
| **admin.py** | routers/admin.py | 178-181 | `models.Device.id`, `deviceType`, `deviceName`, `polatis_name` | Filter (multi-column) | String columns for complex WHERE |
| **admin.py** | routers/admin.py | 188-192 | `models.Device.id`, `ip_address`, `deviceType`, `deviceName` | Filter (multi-column) | String columns for complex WHERE |
| **admin.py** | routers/admin.py | 200-201 | `models.Device.deviceType`, `deviceName` | Filter (equality) | String columns for WHERE clause |
| **admin.py** | routers/admin.py | 203 | `models.Device.ip_address` | Bulk update | String column for SET clause |
| **recommendation_engine.py** | services/ | 64 | `models.Device.device Type` | JOIN filter | String column for JOIN ON clause |

**Total Query Access Points**: 10 locations

**Critical Finding**: All queries use `models.Device.deviceType` as a **column in WHERE clauses**, but InventoryDevice has `deviceType` as a **@property** that requires a JOIN to `device_types`.

### 1.2 Backend Entity Attribute Access

| Component | File | Line | Field Accessed | Access Type | Required Semantics |
|-----------|------|------|----------------|-------------|-------------------|
| **admin.py** | routers/admin.py | 125-133 | All fields | Entity creation (constructor) | All fields assignable in `__init__` |
| **admin.py** | routers/admin.py | 163-164 | `deviceType`, `deviceName` | Read | Property/attribute read |
| **admin.py** | routers/admin.py | 207-213 | `status`, `deviceType`, `deviceName`, `maintenance_*`, `*_Port` | Write (assignment) | All fields must be writable attributes |
| **admin.py** | routers/admin.py | 234-236 | `device.deviceType`, `deviceName`, `ip_address` | Read (response) | Property/attribute read via relationship |
| **admin.py** | routers/admin.py | 266-268 | `booking.device.deviceType`, `deviceName`, `ip_address` | Read (response) | Property/attribute read via relationship |
| **admin.py** | routers/admin.py | 3 04-306 | `device.deviceType`, `deviceName`, `ip_address` | Read (response) | Property/attribute read via relationship |
| **topology_resolver.py** | services/ | 75-80 | `deviceType`, `deviceName`, `ip_address`, `status`, `Out_Port`, `In_Port` | Read (dict assignment) | All properties readable |
| **topology_resolver.py** | services/ | 107 | `device.status` | Read (conditional) | String value for comparison |
| **topology_resolver.py** | services/ | 120 | `device.status` | Read (conditional) | String value for comparison |
| **topology_resolver.py** | services/ | 123, 126-127 | `maintenance_start`, `maintenance_end` | Read + parsing | String value with specific format |
| **recommendation_engine.py** | services/ | 252 | `device.status` | Read (conditional) | String value for comparison |

**Total Entity Access Points**: 40+ individual field accesses

**Critical Finding**: All fields accessed via `device.field_name` syntax. Properties must work identically to direct columns.

### 1.3 Pydantic Schema Requirements

| Schema | File | Lines | Fields Required | Serialization Type |
|--------|------|-------|-----------------|-------------------|
| `DeviceCreate` | schemas.py | 434-451 | All 10 legacy fields | Input validation |
| `DeviceResponse` | schemas.py | 454-477 | All 10 legacy fields + id | Output serialization (orm_mode=True) |
| `DeviceUpdateFull` | schemas.py | 484-501 | All 10 legacy fields | Input validation |

**Required Fields for Schema Compatibility**:
1. `id` (int)
2. `polatis_name` (Optional[str])
3. `deviceType` (str) ‚ö†Ô∏è 
4. `deviceName` (str) ‚ö†Ô∏è
5. `ip_address` (Optional[IPvAnyAddress])
6. `status` (str)
7. `maintenance_start` (Optional[str])
8. `maintenance_end` (Optional[str])
9. `Out_Port` (int) ‚ö†Ô∏è
10. `In_Port` (int) ‚ö†Ô∏è

**Critical Finding**: Pydantic uses `orm_mode=True`, which means it will call **getters** on the ORM object. Properties must be readable.

### 1.4 Frontend Field Access (From Phase U0 Audit)

| Component | File | Fields Used | Usage Type |
|-----------|------|-------------|-----------|
| **ManageDevices** | admin/ManageDevices.js | All 10 fields | Full CRUD, forms, display |
| **ScheduleTable** | client/ScheduleTable.js | `deviceName`, `maintenance_*` | Display, parsing |
| **AdminScheduleTable** | admin/AdminScheduleTable.js | `deviceName`, `deviceType`, `maintenance_*` | Display, grouping |
| **BookingAllDay** | client/BookingAllDay.js | `deviceName`, `deviceType`, `ip_address` | Search, filtering |
| **TimelinePanel** | client/v2/TimelinePanel.js | All fields except ports | Search, display, maintenance logic |
| **PatchListPanel** | client/v2/PatchListPanel.js | `polatis_name` | Device ID mapping |

**Frontend Expectations**:
- All fields returned in API responses
- `maintenance_start` / `maintenance_end` format: `"All Day/YYYY-MM-DD"` or `"7 AM - 12 PM/YYYY-MM-DD"`
- Status values: `"Available"`, `"Maintenance"`, `"Unavailable"` (case-sensitive)
- All integers must be numeric (not strings)

---

## Step 2: InventoryDevice Coverage Check

### 2.1 Field-by-Field Coverage Matrix

| Legacy Field | Column? | Property? | JOIN? | NULL Safe? | Crash Risk? | Notes |
|-------------|---------|-----------|-------|------------|-------------|-------|
| **id** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚ùå No | Direct column, PK |
| **polatis_name** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚ùå No | Direct column, nullable |
| **deviceType** | ‚ùå No | ‚úÖ Yes | üî¥ **YES** | ‚ö†Ô∏è  Partial | üî¥ **YES** | Property returns `None` if device_type not loaded |
| **deviceName** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚ùå No | Property maps to `name` column |
| **ip_address** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚úÖ Yes | ‚ùå No | Property maps to `mgmt_ip` column |
| **status** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚ö†Ô∏è  **NO** | üî¥ **YES** | Column uses inventory values, needs mapping |
| **maintenance_start** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚ùå No | Column added in U1, nullable |
| **maintenance_end** | ‚úÖ Yes | ‚ùå No | ‚ùå No | ‚úÖ Yes | ‚ùå No | Column added in U1, nullable |
| **Out_Port** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚ö†Ô∏è  Partial | ‚ö†Ô∏è  **YES** | Returns 0 if `polatis_port_range` is NULL |
| **In_Port** | ‚ùå No | ‚úÖ Yes | ‚ùå No | ‚ö†Ô∏è  Partial | ‚ö†Ô∏è  **YES** | Returns 0 if `polatis_port_range` is NULL |

### 2.2 Risk Analysis per Field

#### üî¥ **CRITICAL RISK: deviceType**

**Current Implementation**:
```python
@property
def deviceType(self):
    return self.device_type.name if self.device_type else None
```

**Problems**:
1. **Query Risk**: `device.deviceType` in WHERE clause won't work. SQLAlchemy can't translate properties to SQL columns.
   ```python
   # This WILL FAIL:
   db.query(InventoryDevice).filter(InventoryDevice.deviceType == "ROADM")
   # Error: InventoryDevice has no attribute 'deviceType' in SELECT context
   ```

2. **N+1 Query Risk**: If `device_type` relationship not eager-loaded, each access triggers a separate query.
   ```python
   devices = db.query(InventoryDevice).all()
   for d in devices:
       print(d.deviceType)  # Triggers 1 query per device = N+1 problem
   ```

3. **NULL Risk**: If `device_type_id` is NULL or relationship fails to load, returns `None` instead of proper error.

**Affected Code**:
- `admin.py` lines 105, 116-117, 179, 191-192, 200-201 (10 filter queries)
- `recommendation_engine.py` line 64 (JOIN filter)

**Impact**: üî¥ **CRITICAL** ‚Äî Queries will raise `AttributeError` or produce incorrect results.

#### üî¥ **CRITICAL RISK: status**

**Current Implementation**:
- Column uses inventory values: `"active"`, `"in_maintenance"`, `"retired"`, etc.
- Scheduler expects: `"Available"`, `"Maintenance"`, `"Unavailable"`
- U1 added `get_scheduler_status()` and `set_scheduler_status()` methods, but they're **not properties**

**Problems**:
1. **Direct Access Mismatch**: `device.status` returns `"active"`, but scheduler expects `"Available"`.
   ```python
   if device.status == "Maintenance":  # WILL FAIL - actual value is "in_maintenance"
       ...
   ```

2. **Query Mismatch**: Queries filtering by status will fail.
   ```python
   # Scheduler expects:
   db.query(Device).filter(Device.status == "Available")
   # But InventoryDevice stores "active"
   ```

3. **Schema Serialization**: Pydantic will serialize raw `status` value, returning `"active"` to frontend which expects `"Available"`.

**Affected Code**:
- `admin.py` lines 128, 207 (direct assignment)
- `topology_resolver.py` lines 78, 107, 120 (conditional reads)
- `recommendation_engine.py` line 252 (conditional read)

**Impact**: üî¥ **CRITICAL** ‚Äî Maintenance checks fail, frontend receives wrong status values.

#### ‚ö†Ô∏è  **MEDIUM RISK: Out_Port / In_Port**

**Current Implementation**:
```python
@property
def Out_Port(self):
    if not self.polatis_port_range:
        return 0
    m = re.search(r"Out=(\d+)", self.polatis_port_range)
    return int(m.group(1)) if m else 0
```

**Problems**:
1. **Default Behavior**: Returns `0` when `polatis_port_range` is NULL. Legacy Device has `Out_Port` / `In_Port` as **non-nullable integers**.
   - Question: Is `0` a valid port number, or should it error?

2. **Write Behavior**: Setter updates `polatis_port_range` string. If someone sets `Out_Port = 0`, it will write `"In=X;Out=0"`.

**Affected Code**:
- `admin.py` lines 132-133, 212-213 (read/write)
- `topology_resolver.py` lines 79-80 (read for graph attributes)

**Impact**: ‚ö†Ô∏è  **MEDIUM** ‚Äî Likely safe if `0` is acceptable default, but semantics differ from non-nullable ints.

#### ‚ö†Ô∏è  **MEDIUM RISK: deviceType Setter**

**Current Implementation** (lines 207-228):
```python
@deviceType.setter
def deviceType(self, value):
    session = object_session(self)
    if not session or not value:
        return
    
    dt = session.query(DeviceType).filter(DeviceType.name == value).first()
    if dt:
        self.device_type = dt
    else:
        # Creates new DeviceType if not found!
        dt = DeviceType(name=value, category="OPTICAL", is_schedulable=True)
        session.add(dt)
        self.device_type = dt
```

**Problems**:
1. **Side-Effect in Setter**: Creates database records as a side-effect. This is dangerous ‚Äî setters should not have transactional side-effects.
2. **Auto-Creation**: Silently creates `DeviceType` records. What if the type name is a typo? It gets created anyway.
3. **Session Dependency**: Requires active session. If called outside session, fails silently (`return`).

**Affected Code**:
- `admin.py` line 208 (`device.deviceType = update.deviceType`)

**Impact**: ‚ö†Ô∏è  **MEDIUM** ‚Äî May create unwanted DeviceType records, but won't crash.

---

## Step 3: Gap Report

### 3.1 Missing Functionality

**None** ‚Äî All required fields exist as either columns or properties.

### 3.2 Ambiguous Semantics

| Item | Issue | Impact |
|------|-------|--------|
| **status** | Inventory uses `"active"` / `"in_maintenance"`, scheduler uses `"Available"` / `"Maintenance"` | Frontend receives wrong values, conditionals fail |
| **Out_Port / In_Port default** | Returns `0` when NULL, legacy has non-nullable columns | Minor ‚Äî likely safe if `0` is valid |
| **deviceType setter** | Creates records as side-effect | Medium ‚Äî may pollute database with typos |

### 3.3 Unsafe NULL Behavior

| Field | NULL Behavior | Risk |
|-------|---------------|------|
| **deviceType** | Returns `None` if `device_type` relationship not loaded | üî¥ High ‚Äî queries expect string, get `None` |
| **status** | Column is non-nullable (default="active") | ‚úÖ Safe |
| **Out_Port / In_Port** | Returns `0` if `polatis_port_range` is NULL | ‚ö†Ô∏è  Medium ‚Äî non-nullable in legacy |
| **maintenance_start / maintenance_end** | Returns `NULL` (new columns) | ‚úÖ Safe ‚Äî always nullable |

### 3.4 Incorrectly Computed Fields

| Field | Computation | Issue |
|-------|-------------|-------|
| **deviceType** | `self.device_type.name` | ‚úÖ Correct computation, but wrong query semantics |
| **Out_Port / In_Port** | Regex parse from `polatis_port_range` | ‚úÖ Correct computation |
| **status** | Direct column access | üî¥ Returns inventory values, not scheduler values |

---

## Step 4: Compatibility Requirements for U2

### 4.1 Required Query Modifications

**All filter queries on `deviceType` must be rewritten to JOIN**:

**Before (Legacy)**:
```python
db.query(models.Device).filter(models.Device.deviceType == "ROADM").all()
```

**After (InventoryDevice)**:
```python
from backend.inventory.models import InventoryDevice, DeviceType

db.query(InventoryDevice).join(DeviceType).filter(DeviceType.name == "ROADM").all()
```

**Affected Files**:
- `backend/scheduler/routers/admin.py` (10 queries)
- `backend/scheduler/services/recommendation_engine.py` (1 query)

**Total Modifications Required**: 11 query rewrites

### 4.2 Required Status Mapping

**Option A: Make `status` a property (RECOMMENDED)**

Convert `status` column to use scheduler values, or create a property:

```python
@property
def status(self):
    """Return scheduler-compatible status."""
    return self.get_scheduler_status()

@status.setter
def status(self, value):
    """Accept scheduler status values."""
    self.set_scheduler_status(value)
```

**Option B: Middleware Translation**

Add response middleware to translate status values before returning to frontend.

**Recommendation**: **Option A** ‚Äî cleaner, works for both queries and responses.

### 4.3 Required Eager Loading

**All queries must eager-load `device_type` relationship**:

```python
from sqlalchemy.orm import joinedload

db.query(InventoryDevice).options(joinedload(InventoryDevice.device_type)).all()
```

**Affected Files**: All files that iterate over devices and access `deviceType`.

---

## Step 5: Test Harness Proposal

### 5.1 Test Suite Structure

```
tests/
‚îî‚îÄ‚îÄ inventory/
    ‚îî‚îÄ‚îÄ test_scheduler_compatibility.py
```

### 5.2 Test Cases

#### Test 1: Property Access

```python
def test_inventory_device_properties():
    """Verify all scheduler properties work."""
    device = InventoryDevice(
        name="Test Device",
        device_type=DeviceType(name="ROADM", category="OPTICAL"),
        mgmt_ip="192.168.1.1",
        polatis_port_range="In=123;Out=456",
        maintenance_start="All Day/2023-10-01",
        maintenance_end="All Day/2023-10-05",
        status="active"
    )
    
    # Test getters
    assert device.deviceName == "Test Device"
    assert device.deviceType == "ROADM"
    assert device.ip_address == "192.168.1.1"
    assert device.Out_Port == 456
    assert device.In_Port == 123
    assert device.maintenance_start == "All Day/2023-10-01"
    assert device.maintenance_end == "All Day/2023-10-05"
    assert device.get_scheduler_status() == "Available"
    
    # Test setters
    device.deviceName = "Updated Device"
    assert device.name == "Updated Device"
    
    device.ip_address = "10.0.0.1"
    assert device.mgmt_ip == "10.0.0.1"
    
    device.Out_Port = 789
    assert "Out=789" in device.polatis_port_range
```

#### Test 2: Query Compatibility

```python
def test_device_type_join_query(db):
    """Verify deviceType filter works with JOIN."""
    # Create test data
    roadm_type = DeviceType(name="ROADM", category="OPTICAL")
    db.add(roadm_type)
    db.flush()
    
    device = InventoryDevice(name="ROADM-1", device_type=roadm_type)
    db.add(device)
    db.commit()
    
    # Test JOIN query
    results = (
        db.query(InventoryDevice)
        .join(DeviceType)
        .filter(DeviceType.name == "ROADM")
        .all()
    )
    
    assert len(results) == 1
    assert results[0].deviceType == "ROADM"
```

#### Test 3: Status Mapping

```python
def test_status_mapping():
    """Verify status translation."""
    device = InventoryDevice(status="active")
    
    # Test getter
    assert device.get_scheduler_status() == "Available"
    
    # Test setter
    device.set_scheduler_status("Maintenance")
    assert device.status == "in_maintenance"
    
    # Test round-trip
    assert device.get_scheduler_status() == "Maintenance"
```

#### Test 4: Pydantic Serialization

```python
def test_pydantic_serialization(db):
    """Verify schemas work with InventoryDevice."""
    from backend.scheduler.schemas import DeviceResponse
    
    # Create device with eager-loaded relationship
    device_type = DeviceType(name="ROADM", category="OPTICAL")
    db.add(device_type)
    db.flush()
    
    device = InventoryDevice(
        name="Test",
        device_type=device_type,
        mgmt_ip="192.168.1.1",
        polatis_port_range="In=123;Out=456",
        status="active"
    )
    db.add(device)
    db.commit()
    
    # Serialize
    response = DeviceResponse.from_orm(device)
    
    # Verify all fields
    assert response.deviceName == "Test"
    assert response.deviceType == "ROADM"
    assert response.ip_address == "192.168.1.1"
    assert response.Out_Port == 456
    assert response.In_Port == 123
    # NOTE: status will be "active", not "Available" unless property is fixed
```

#### Test 5: Maintenance Parsing

```python
def test_maintenance_format():
    """Verify maintenance fields use scheduler format."""
    device = InventoryDevice(
        name="Test",
        maintenance_start="7 AM - 12 PM/2023-10-01",
        maintenance_end="12 PM - 6 PM/2023-10-05"
    )
    
    assert device.maintenance_start == "7 AM - 12 PM/2023-10-01"
    assert device.maintenance_end == "12 PM - 6 PM/2023-10-05"
    
    # Test parsing logic from topology_resolver
    start_str = device.maintenance_start.split("/")[-1]
    assert start_str == "2023-10-01"
```

### 5.3 Test Execution Plan

```bash
# Run tests
pytest tests/inventory/test_scheduler_compatibility.py -v

# Expected Results:
# - Test 1: ‚úÖ PASS (all properties work)
# - Test 2: ‚úÖ PASS (JOIN query works)
# - Test 3: ‚úÖ PASS (status mapping works)
# - Test 4: ‚ö†Ô∏è  FAIL (status will be "active", not "Available") 
# - Test 5: ‚úÖ PASS (maintenance format correct)
```

---

## Final Answer: Is InventoryDevice 100% Scheduler-Safe?

### Answer: üü° **95% Safe ‚Äî 3 Modifications Required**

**InventoryDevice CAN safely replace Device, BUT requires these changes in U2**:

### Required Modifications (Non-Negotiable)

1. **Rewrite 11 deviceType Filter Queries** üî¥
   - Replace `models.Device.device Type ==` with `DeviceType.name ==` + JOIN
   - Add `joinedload(InventoryDevice.device_type)` to all list queries
   - **Files**: `admin.py`, `recommendation_engine.py`

2. **Fix status Property** üî¥
   - Convert `status` column to property using `get_scheduler_status()` / `set_scheduler_status()`
   - OR: Ensure column stores scheduler values (`"Available"`, `"Maintenance"`)
   - **Files**: `inventory/models.py`

3. **Add Eager Loading** üî¥
   - All `db.query(InventoryDevice).all()` must use `.options(joinedload(InventoryDevice.device_type))`
   - **Files**: All scheduler files

### Optional Improvements

4. **Fix deviceType Setter Behavior** ‚ö†Ô∏è
   - Remove auto-creation logic
   - Raise error if DeviceType doesn't exist
   - **Files**: `inventory/models.py`

5. **Clarify Out_Port / In_Port NULL Behavior** ‚ö†Ô∏è
   - Document that `0` is valid default
   - OR: Raise error if `polatis_port_range` is NULL
   - **Files**: `inventory/models.py`

### Risks if NOT Fixed

| Risk | Impact | Severity |
|------|--------|----------|
| deviceType queries fail | `AttributeError` in filter queries | üî¥ **CRITICAL** ‚Äî App crashes |
| status mismatch | Maintenance logic breaks, frontend shows wrong values | üî¥ **CRITICAL** ‚Äî Business logic fails |
| N+1 queries | Performance degradation (100+ devices = 100+ extra queries) | üî¥ **CRITICAL** ‚Äî Slow app |
| deviceType setter | Unwanted DeviceType records created | ‚ö†Ô∏è  **MEDIUM** ‚Äî Data pollution |
| Port defaults | Minor semantic difference from legacy | ‚ö° **LOW** ‚Äî Likely benign |

---

## Recommendations for Phase U2

### Pre-Migration Checklist

- [ ] Run test harness and verify all tests pass
- [ ] Implement status property fix
- [ ] Document all query modifications needed
- [ ] Create query rewrite script/guide
- [ ] Test eager loading performance

### Migration Sequence

1. **U2.1**: Fix `status` property in `InventoryDevice`
2. **U2.2**: Rewrite all `deviceType` filter queries
3. **U2.3**: Add eager loading to all device list queries
4. **U2.4**: Update scheduler imports to use `InventoryDevice`
5. **U2.5**: Run full integration tests
6. **U2.6**: Execute FK migration
7. **U2.7**: Remove legacy `Device` model

### Success Criteria

‚úÖ All scheduler tests pass  
‚úÖ No AttributeError in logs  
‚úÖ Frontend receives correct field values  
‚úÖ No N+1 query warnings in logs  
‚úÖ Maintenance logic works correctly  
‚úÖ Device CRUD operations work  

---

**End of Phase U1.5 Compatibility Audit Report**

**Status**: üü° **InventoryDevice is scheduler-compatible with required modifications**
